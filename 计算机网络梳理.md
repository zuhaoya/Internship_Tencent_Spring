#### 计算机网络基础

----

##### 请你说一下TCP怎么保证可靠性

1）**序列号、确认应答、超时重传**

数据到达接收方，接收方需要发出一个确认应答，表示已收到该数据段，并会返回一个序列号，表明它下一次所需要接收的数据段的序列号。

如果发送方迟迟未收到确认应答，就会在一定时间内重传数据。这个时间间隔为 rtt(报文段往返时间) + 抖动时间

抖动时间：数据包的分段是经过不同线路到达，基于网络环境的不同往返时间会发生大幅度的摇摆。

2）**窗口控制与快速重发**

TCP利用窗口控制来提高传输速度，窗口大小就是指无需等待确认应答而可以继续发送数据的最大值（实现使用了缓冲区）

这个时候如果出现了数据段丢失，则接收方会反复发送缺失段序列号，当发送端收到三次重复序列号则立即重发该数据段

3）**拥塞控制**

慢启动 + 拥塞避免 + 根据重发机制选择不同的方案【超时重传 / 快速重传】

慢启动：定义拥塞窗口，一开始设置为1，之后每次收到确认应答，大小*2

拥塞避免：为慢启动设定阈值，当到达阈值后不再指数上升而是加法上升

对于超时重传：阈值减半，并将窗口大小置1，重新进入慢启动过程

对于快速重传：阈值减半，并将窗口大小置为阈值+3，继续加法上升

->这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。



##### TCP的三次握手和四次挥手

**三次握手**

1）客户端发送一个SYN包给服务端

2）服务端收到SYN包后，返回一个确认应答以及一个SYN包

3）客户端收到SYN包后，会返回一个确认应答

连接建立完毕，可以正常传输数据 

**四次握手**

1）数据传输完成后，客户端会发出FIN包

2）服务器端收到FIN包后，会返回一个确认应答 

3）当服务器无数据需要发送时，服务器发出FIN包 

4）客户端收到FIN包后，会返回一个确认应答 此时客户端会进入TIME_WAIT状态

等待2MSL(报文段最大生存时间)然后关闭连接

##### TCP三次挥手和四次握手的原因

1）三次握手

三次握手可以防止**已经失效的连接请求报文突然又传输到服务器**端导致的服务器资源浪费。一些失效的SYN包会导致服务器 一直等待 客户端发送数据

2）四次挥手

为了确保数据可以完全被传输，在建立连接的时候，当服务器收到客户端的SYN包的时候，可以将确认应答和SYN包同时传送回去，但是在断开连接的时候，当服务器端接受到FIN包的时候其可能还需要发送数据，当其数据完全发送完，才会发FIN包给客户端。



##### **怎么保证四次挥手的最后一个包没有丢**

最后客户端会等待2MSL，如果没有接受到因超时重传服务端再次发送的FIN包的话就证明服务端已收到确认应答



**为什么基于TCP的程序往往都有个应用层的心跳检测机制？**
是为了预防建立好的连接突然客户端故障了，服务器不能一直等待下去，需要一个计时器和探测包来检测.



**服务端运行一段时间后，套接字出现了大量的Close_Wait状态，最有可能是什么原因导致的？**

close-wait状态是因为client已经发出释放连接信号了 已经没有数据传输过来，但是server端还有数据未发送完，这个时候就有close-wait状态了！



**三次握手的数据携带**

三次握手的第一次可以携带数据嘛？不可以，还未建立连接

三次握手的第三次可以携带数据嘛？可以，能够发出第三次握手报文的主机，肯定会收到第二次握手报文，是合法的用户，当确认应答传给服务端的时候，其状态瞬间变为连接建立，然后处理数据



##### 三次握手中，最后一次回复丢失，会发生什么？

rst 包 用于强制关闭tcp连接 

1）客户端第三次丢失是感应不到的，所以，会当作正常情况发送报文，Server端将以 RST包响应要求，此时，客户端知道，第三次握手失败。

2）服务器经过一段时间后，没有得到第三次握手的响应，则重新发送第二次握手的包。默认为5次重发。间隔时间为3，6，12秒，之后就放弃。



##### TCP的seq和ack号计算方法

1）确认号：
在握手和结束时确认号应该是对方序列号加1,传输数据时则是对方序列号加上对方携带应用层数据的长度，如果对方携带应用层数据长度为0，则ack与对方序列号相同，不要+1
2）序列号：
在握手和结束时序列号应该是上次序列号+1，传输数据时则是上次的序列号加上上次应用层数据发送长度，如果数据长度为0，则seq与上次一样，不要+1



**TCP和UDP的区别以及各自优势**

1）TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。

2）UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。

既然UDP是一种不可靠的网络协议，那么还有什么使用价值或必要呢？

其实不然，在有些情况下UDP协议可能会变得非常有用。

因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。



**UDP丢包和无序 的解决方法**

应用层模仿传输层TCP的可靠性传输

1、添加seq/ack机制，确保数据发送到对端。

2、添加发送和接收缓冲区，主要是用户超时重传。

3、添加超时重传机制。

或是采用一些已有的可靠传输算法 模拟TCP协议 重发请求协议



##### UDP快在哪里

1.不需要建立连接 2.对于收到的数据，不用给出确认 3.没有超时重发机制 4.没有流量控制和拥塞控制



##### TCP/IP 模型 和 OSI模型

TCP/IP 四层模型：链路层(vlan mac)、网络层(ip arp)、运输层(tcp udp)、应用层（http https）

OSI 七层模型：物理层，链路层，网络层，运输层，会话层，表示层，应用层

交换机工作在链路层 路由器工作在网络层 



##### HTTP 的工作原理 及 在浏览器键入URL会发生什么

1)HTTP协议

超文本传输协议 属于应用层 工作于客户端-服务端架构上 

简单快速 （只需传送请求方法和路径）灵活（允许传输任意类型的数据对象）无连接（每次只处理一个请求）无状态（对于事务处理无记忆功能）支持B/S或C/S模式 默认端口80 

HTTP的请求/响应步骤：

1. 客户端连接到web服务器
2. 发送HTTP请求
3. 服务器接收请求并返回HTTP响应
4. 释放连接（session / cookie）
5. 客户端浏览器解析HTML内容

2）在浏览器地址键入URL,按下回车键：

1. 浏览器向DNS服务器请求解析该URL的域名所对应的IP地址
2. 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接
3. 浏览器发出读取文件的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器
4. 服务器对浏览器请求做出响应 并把对应的HTML文本发送给浏览器
5. 释放TCP连接
6. 浏览器解析HTML文本 



##### get和post的区别

1）get 方式的请求，浏览器报文头部和data一起发送

​      post 方式的请求，浏览器先发送header 再发送data

2）区别：

1.  get 参数通过url传递 参数直接暴露 不安全 且 长度有限制 产生一个TCP包
2. post 参数放在request body 中，安全，多种方式编码 两个TCP数据包



##### HTTP 和 HTTPS 的区别

1）HTTP 明文传输数据，端口号80 

2）HTTPS 数据加密，在TCP三次握手之后，需要进行SSL的handshake, 协商加密使用的对称加密密钥， 服务端需要申请证书，客户端需要安装对应的根证书



##### 常见的HTTP返回码 

1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。

400 wrong 403 fobidden 404 not found 500 服务错误



##### cookie 和 session 关系的区别 

>  Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的

1）cookie 

Cookie是**客户端**保存用户信息的一种机制，用来记录用户的一些信息

可以理解为本地保存用户信息，下次再访问相同网站时，将cookie一同发给服务器，服务器据此返回之前信息 分为会话cookie 保存在内存 浏览器关闭则失效 若设置过期时间，则保存在硬盘

2）session 

session 是服务器端记录客户状态的机制，再次登陆时，依据sessionID 查询该客户的状态信息 

cookie 不是很安全 保存数据小 



##### 网址访问过程（dns域名解析）

浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。



##### DNS报文用什么协议传递，为什么

TCP + UDP 

区域传送时 选择 tcp 同步数据 辅域名服务器向主域名服务器查询以了解数据是否有变动

客户端向dns服务器查询域名 数据量比较小 udp即可 



##### socket 编程

socket 是对TCP/IP 协议族的一种封装，可以实现网络间不同计算机上的进程通信，利用三元组（ip地址，协议，端口）唯一标识网络中的进程。

TCP/IP协议规定：网络数据流应采用**大端字节序**，即**低地址高字节**



##### 浏览器如何验证HTTPS证书的合法性？

1）证书**是否是信任的有效证书**，浏览器会内置信任的根证书，检查web服务器的证书是不是这些信任根发的 或是信任根的二级证书机构颁发的 

2）验证**对方是不是上述证书的合法持有者** 即 证明对方是否持有证书的对应私钥 有两种验证方法 一种是让对方签个名 我用证书验证签名 ； 另一种是 用证书做个信封 看对方是否可以解开 



##### https的加密方式

常见的加密技术：

1）数字证书  

由权威公正的第三方机构 即CA中心签发的证书 用以证明自己的身份 和 识别他人的身份

2）对称加密算法 

3）非对称加密算法 

公开密钥和私有密钥是一对 如果公开密钥对数据加密 只有对应的私钥可以解密 如果私钥加密 则对应的公钥解密 

4）hash算法 

消息摘要 长度固定 唯一对应一个消息或文本 



**https握手的过程**

1）获得网站证书之后浏览器要做以下工作：
a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（这其实就是用于之后数据通信的对称加密算法的秘钥），并用证书中提供的公钥加密（对秘钥的加密采用非对称的方法）。
c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数（对称算法的秘钥）对消息进行加密，最后将之前生成的被公钥加密的随机数密码，HASH摘要值（已经被对称算法加密）一起发送给服务器

2）网站接收浏览器发来的数据之后要做以下的操作：
a) 使用自己的私钥将信息解密并取出浏览器发送给服务器的随机密码（得到了对称加密算法的秘钥），使用密码解密浏览器发来的握手消息（用对称算法的秘钥解HASH摘要值），并验证HASH是否与浏览器发来的一致。
b) 使用随机密码加密一段握手消息，发送给浏览器。
5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

![单项认证](https://img-blog.csdn.net/20170807170858511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdXN0Y2N3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)







