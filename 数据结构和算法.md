#### 数据结构和算法

---

#### 排序和查找

##### 归并排序 

1）确立分界点 mid  = (l+r) /2

2）递归排序left  和 right  

3）归并 --- 合二为一 

双指针算法 

```c++
#include<iostream>
using namespace std;
const int N = 100005;
int q[N], temp[N];

void merge_sort(int q[], int l, int r)
{
    if(l >= r) return;
    int mid = l + r >> 1; // 确立分界点
    
    merge_sort(q, l, mid), merge_sort(q, mid+1, r); // 递归排左右 
    
    // 归并 此时 左右分别排好了 
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r)
    {
        if(q[i] <= q[j])
            temp[k++] = q[i++];
        else 
            temp[k++] = q[j++];
    }
    // 可能还有剩的 
    while(i <= mid) temp[k++] = q[i++];
    while(j <= r) temp[k++] = q[j++];
    
    //复制回去 
    for(i = l, k = 0; i <= r; i++, k++)
        q[i] = temp[k];
    
}
int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++)
        cin >> q[i];
    merge_sort(q, 0, n-1);
    for(int i = 0; i < n; i++)
        cout << q[i];
    return 0;
}
```



##### 手写快排

```c++
/*
根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。
*/

#include<iostream>
using namespace std;
const int N = 100005;
int a[N];
void quick_sort(int a[], int left, int right)
{
    if(left >= right)
        return;
    int i = left - 1, j = right + 1, mid = a[(left + right) / 2];
    while(i < j)
    {
        do i++; while(a[i] < mid);
        do j--; while(a[j] > mid);
        if(i < j) swap(a[i], a[j]);
    }
    quick_sort(a, left, j);
    quick_sort(a, j + 1, right);
}
int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++)
        cin >> a[i];
   	quick_sort(a, 0, n-1);
    for(int i = 0; i < n; i++)
        cout << a[i];
    return 0;
}
```

##### 手写第k大的数 

```c++
#include<iostream>
using namespace std;
const int N = 100005;
int a[N];

int quick_sort(int a[], int left, int right, int k)
{
    if(left >= right)
        return a[l];
    int i = left - 1, j = right + 1, mid = a[(left + right) / 2];
    while(i < j)
    {
        do i++; while(a[i] < mid);
        do j--; while(a[j] > mid);
        if(i < j) swap(a[i], a[j]);
    }
    if(j - left + 1 > k) return quick_sort(a, left, j, k);
    else return quick_sort(a, j+1, right, k - (j - left + 1));
}
int main()
{
    int n, k;
    cin >> n >> k;
    for(int i = 0; i < n; i++)
        cin >> a[i];
    cout << quick_sort(q, 0, n-1, k) << endl;
    return 0;
}
```

##### 海量数据 如何去取 最大的 K 个

1) 快排： 使用快排排序 取前k个 最快 O(nlogn) 内存可容纳所有数据

2）快速选择的方法 quick_sort_k 

首先选择一个划分元 将比这个划分元大的元素放到它的前面 比划分元小的元素放到它的后面，此时完成一趟排序 如果此时划分元的序号恰好等于k 则停止 可以提高效率

2) 堆排序

局部淘汰法 先读取前K个数，建立一个**最小堆**，然后将剩余的所有数字依次与最小堆的堆顶比较，看是否插入，最终堆即为我们所需的最大的k个元素

3）分治法：

将全部数据分成N份 （每份数据可读入内存），找到每份数据中最大的K个数，此时剩下N*K个数，直到所有的数可以读入内存 

4）hash法

如果数据中有很多重复的数据，可以先通过hash法 把重复的数据去掉，处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。

##### 10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？

（1GB = 1000 MB = 1000,000 KB = 1000,000,000 B 一亿字节

​    2^30 Byte = (2^10)^3 Byte = 1024 * 1024 * 1024 Byte = 1GB     ）

1）位图法（Bitmap）

1个int 整型占4字节, 32bit 那么把所有int整型数字表示出来需要2^32bit位的空间 2^32 bit/8 = 2^29 Byte，大约等于512MB

int temp[2^32 / 32 + 1];

> temp[0]: 0-31
>
> temp[1]:32-63
>
> ....

如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)

如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)

(这里不可对重复的数据进行排序和查找)

优化：2-BitMap 

即为每个整数分配2bit，用不同的0、1组合来标识特殊意思，如00表示此整数没有出现过，01表示出现一次，11表示出现过多次，就可以找出重复的整数了，其需要的内存空间是正常BitMap的2倍

2) 分治法

哈希分桶的思想是先遍历一遍，按照hash分N桶（比如1000桶），映射到不同的文件中。这样平均每个文件就10MB，然后分别处理这1000个文件，找出没有重复的即可。一个相同的数字，绝对不会夸文件，有hash做保证

##### 42亿QQ，O(1)时间复杂度完成查找

==bit-map 具体实现 要了解一下==



#### 链表







#### 数组与字符串

##### 两数之和 

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

```c++
// 直接用哈希表存储 <int, int> nums[i] i 
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map <int,int> dict;
        for(int i = 0; i < nums.size(); i++)
        {
            if(dict.count(target - nums[i]))
            {
                return {dict[target-nums[i]], i};
            }else
            {
                dict[nums[i]] = i;
            }
        }
        return {0,0};
    }
};
```



##### 寻找两个有序数组的中位数

给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

二分搜索。为了方便讨论我们首先假设两个数组的长度分别为n,m，并且有n <= m，并且n + m是奇数，那么我们要找的数字其实就是两个数组合并后第k = (n + m + 1) / 2小的数字。我们尝试将两个数组划分成两个部分，A数组左侧有i个元素，B数组左侧有j个元素，并且i + j = k。

          left_part          |        right_part
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[n-1]
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[m-1]
如果我们能够保证A[i - 1] < B[j] && B[j - 1] < A[i]，那么说明left_part中的所有元素都小于right_part中的元素，并且第k小的元素就是max(A[i - 1],B[j - 1])。

如果A[i - 1] > B[j]说明i偏大，我们需要将i缩小尝试得到A[i - 1] < B[j]。

如果B[j - 1] > A[i]说明i偏小，我们需要将i放大尝试得到B[j - 1] < A[i]。

那么我们使用二分查找来找到左边放多少个i数字比较合适，初始搜索区间为[0:n]，如果左边放置i个元素，那么右边放置j = k - i个元素。

接下来我们考虑一些边界条件：

如果i = 0，相当于最小的k个数都在B中，这时整体第k小的元素就是B[k - 1]

如果j = 0，相当于最小的k个数都在A中，这时整体第k小的元素就是A[k - 1]

否则，最小的k个数，i个在A中，j个在B中，这时整体第k小的元素就是max(A[i - 1],B[j - 1])

上面我们的讨论，我们是基于n + m是奇数的，这时候我们只需要找到上述元素就好了，但是当n + m是偶数的时候，我们还需要找到right_part中最小的元素，这个值也就是min(A[i],B[j])，这时候仍然需要讨论一些边界情况：

如果i = n，那么A中没有比A[i - 1]还大的了，那么只能是B[j]

如果j = m，那么B中没有比B[j - 1]还大的了，那么只能是A[i]

否则，整体第k + 1小的元素就是min(A[i],A[j])

```c++
 double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
     int n = nums1.size(), m = nums2.size();
     if(n > m) // 我们这里保证 n 是短的 m 是长的 
     {
         swap(nums1, nums2);
         swap(n, m);
     }
     int l = 0,r = n,k = (n + m + 1) / 2;
     // 二分查找
     while(l <= r)
     {
         int i = (l+r)/2, j = k - i; // 这里i取什么都可
         if(i < n && nums1[i] < nums2[j - 1]) // 一定要保证 A[i] > B[j-1]
             l = i + 1;
         else if(i > 0 && nums1[i - 1] > nums2[j]) // 一定要保证 A[i-1] < B[j]
             r = i - 1;
         else 
         {
             int max_left, min_right;
             if(i == 0) max_left = nums2[k - 1];
             else if(j == 0) max_left = nums1[k - 1];
             else max_left = max(nums1[i-1], nums2[j-1]);
             
             if((n+m) % 2 == 1) return max_left;
             
             if(i == n) min_right = nums2[j];
             else if(j == m) min_right = nums1[i];
             else min_right = min(nums1[i], nums2[j]);
             return (max_left + min_right) / 2.0;
         }
     }
     return 0.0;
 }
```







#####  最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

```c++
// 动态规划 
// dp[i][j] = dp[i+1][j-1] && s[i] == s[j]
// dp[i][j] 为0 / 1 表示其是否为回文子串 是则更新 i - j 的值 取最大 以及起点 
class Solution {
public:
    string longestPalindrome(string s) {
        int length = s.length();
        int dp[1005][1005] = {{0,0}};
        //vector<vector<int>>dp (length,vector<int>(length,0));
        int max = 1;
        int start = 0;
        if(length <=1 )
            return s;
        for(int i = 0; i < length; i++)
            dp[i][i] = 1;
        for(int i = 1; i < length; i++)
        {
            for(int j = i - 1; j >= 0; j--)
            {
                if(s[j] == s[i])
                {
                    if(i - j + 1 <= 3) // 三个 两个 都可过
                        dp[j][i] = 1;
                    else
                        dp[j][i] = dp[j+1][i-1];
                }
                if(dp[j][i]) // 如果 i - j 回文 更新最长回文串的起点和大小
                {
                    int temp = i - j + 1;
                    if(temp > max)
                    {
                        max = temp;
                        start = j;
                    }
                }
                    
            }
        }
        return s.substr(start, max);
        
    }
};
```



##### 字符串转换整数 (atoi)

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

- 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
- 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
- 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。



```c++
// 直接模拟 
// 先把 “ ”读掉 
// 在读掉正负号 
// 顺次读数据即可 注意 判是否溢出 INT_MAX
class Solution {
public:
    int myAtoi(string str) {
        int i = 0, temp = 0, res = 0;
        bool flag = true;
        while(str[i] == ' ')
            i++;
        if(str[i] == '-')
            flag = false;
        if(str[i] == '-' || str[i] == '+')
            i++;
        while(i < str.length() && str[i] <= '9' && str[i] >= '0')
        {
            temp = str[i] - '0';
            //判断是否溢出
            if(res > INT_MAX / 10 || (res == INT_MAX / 10 && temp > 7)) // 判断是否溢界 有可能是负数 所以等于7 不溢出界 
                return flag ? INT_MAX : INT_MIN;
            res = res * 10 + temp;
            i++;
        }
        return flag ? res : -res;
    }
};
```



##### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```c++
 // 排序后 只需要比较最小字典序的字符串和最大字典序的字符串
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int nums = strs.size();
        if(nums == 0)
            return "";
        if(nums == 1)
            return strs[0];
        sort(strs.begin(), strs.end());
        for(int i = 0; i < min(strs[0].length(), strs[nums-1].length()); i++)
            if(strs[0][i] != strs[nums-1][i]) 
                return strs[0].substr(0,i);
        return strs[0];
    }
};
```



##### 三数之和

给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```c++
// 去重复？ 
// 先定下一个数，然后再用双指针去遍历剩下的两个数 
// 当然要先排序 
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int> > res;
        int a = 0, b = 0, c = 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        
        for(int i = 0; i < n - 2; i++)
        {
            a = nums[i];
            int p = i+1, q = n-1;
            while(p < q)
            {
                b = nums[p], c = nums[q];
                if(a + b < -c)
                    p++;
                else if(a + b > -c)
                    q--;
                else
                {
                    if(p == i + 1)
                    {
                        vector<int> temp {a,b,c};
                        res.push_back(temp);
                        temp.clear();
                    }
                    if(nums[i] != nums[i+1] ) //{-1,-1,2,3,4} {-1,-1,0,1}
                    {
                        vector<int> temp {a,b,c};
                        res.push_back(temp);
                        temp.clear();
                    }
                    p++, q--;
                }
            }
        }
        return res;
    }
};
```



##### 最接近的三数之和

给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

```c++
// 固定一个数 双指针搜索另外两个数 
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int a, b, c;
        int n = nums.size();
        int temp = INT_MAX;
        int res = 0;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < n; i++)
        {
            a = nums[i];
            int p = i + 1, q = n - 1;
            while(p < q)
            {
                b = nums[p], c = nums[q];
                if(b + c < target - a)
                    p++;
                else q--;
                if(temp > abs(target -a-b-c))
                {
                    temp = abs(target -a-b-c);
                    res = a + b + c;
                    cout << a << b << c << endl;
                }
            }
        }
        return res;
    }
};
```



##### 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

```c++
// 用栈存 然后依次判断即可
class Solution {
public:
    bool isValid(string s) {
        int length = s.length();
        stack<char> stk;
        if(length == 0)
            return true;
        if(length == 1)
            return false;
        for(int i = 0; i < length; i++)
        {
            if(s[i] == '(' || s[i] == '{' || s[i] == '[' )
                stk.push(s[i]);
            else
            {
                if(stk.empty()) return false;
                if(s[i] == ')' && stk.top() != '(') return false;
                if(s[i] == ']' && stk.top() != '[') return false;
                if(s[i] == '}' && stk.top() != '{') return false;
                stk.pop();
            }
        }
        if(stk.empty())
            return true;
        return false;
            
    }
};
```



##### 删除排序数组中的重复项

给定一个排序数组，你需要在 **原地** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 **原地 修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

```c++
// 新旧指针 更新 即可 
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        int old = 0, idx_new = 0;
        int n = nums.size();
        while(old < n)
        {
            if(nums[idx_new] != nums[old])
                nums[++idx_new] = nums[old];
            old++;            
        }
        return idx_new + 1;
    }
};
```



##### 盛最多水的容器

给你 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

```c++
// 双指针 排除柱子 最小的柱子才起作用 每次记录当前的体积 
class Solution {
public:
    int maxArea(vector<int>& height) {
        int length = height.size();
        int p = 0, q = length - 1;
        int max = 0, coloum = 0;
        while(p < q)
        {
            if(height[p] < height[q])
            {
                coloum = height[p] * (q - p );
                p++;
            }else
            {
                coloum = height[q] * (q - p );
                q--;
            }
            max = max > coloum ? max : coloum;
        }
        return max;
    }
};
```



##### 字符串相乘

定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

```c++
// 模拟乘法，将所有数据不进位直接存入数组，最后统一进位即可
// 先reverse 一下 好算
class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == "0" || num2 == "0") {
            return "0";
        }
        int len1 = num1.size(), len2 = num2.size();
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());
        vector<int> res(len1+len2, 0);
        
        for(int i = 0; i < len1; i++)
            for(int j = 0; j < len2; j++)
                res[i + j] += (num1[i] - '0') * (num2[j] - '0');
        
        for(int i = 0; i < len1 + len2; i++)
        {
            if(res[i] > 9)
            {
                int temp = res[i];
                res[i] = temp % 10;
                res[i+1] += temp / 10;   
            }
        }
        
        int idx = res[len1+len2-1]  == 0 ? len1+len2-2 : len1+len2-1;
        string ans = "";
        while(idx >= 0)
            ans += (res[idx--] + '0');
        return ans;
    }
};
```



##### 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。

不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。

```c++
//两个指针 首尾交换
class Solution {
public:
    void reverseString(vector<char>& s) {
        int length = s.size();
        int p = 0, q = length - 1;
        char temp;
        while(p < q)
        {
            temp = s[q];
            s[q] = s[p];
            s[p] = temp;
            p++, q--;
        }
    }
};
```



##### 反转字符串中的单词 III

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

```c++
// 判断空格 然后 每个单词 再 利用双指针反转即可 
class Solution {
public:
    string reserve(string s, int start, int end)
    {
        char temp;
        while(start < end)
        {
            temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start++;
            end--;
        }
        return s;
    }
    string reverseWords(string s) {
        
        int length = s.length();
        int p = 0, q = length - 1;
        int start = 0;
        for(int i = 0; i < length; i++)
        {
            if(s[i] == ' ')
            {
                s = reserve(s, start, i-1);
                start = i + 1;
            }
            else if(i == length - 1)
                s = reserve(s, start, i);
        }
        return s;
    }
};
```



#####  除自身以外数组的乘积

给你一个长度为 *n* 的整数数组 `nums`，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

```c++
// 双指针 
// 用left right 去分别记录 两边的乘积 
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int left = 1, right = 1;
        int length = nums.size();
        vector<int> res(length, 1);
        for(int i = 0; i < length; i++)
        {
            res[i] *= left;
            left *= nums[i];
            
            res[length - 1 - i] *= right;
            right *= nums[length - 1 - i];
        }
        return res;
    }
};
```



#####  存在重复元素

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

```c++
// 哈希 
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_map<int, int> dict;
        int length = nums.size();
        if(length <= 1)
            return false;
        for(int i = 0; i < length; i++)
        {
            if(dict.count(nums[i]))
                return true;
            dict[nums[i]]++;
        }
        return false;
    }
};
```



##### 螺旋矩阵

给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

```c++
// 打印蛇形矩阵 用 偏移量 
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        if(matrix.empty())
            return res;
        int dx[4] = {0,1,0,-1};
        int dy[4] = {1,0,-1,0};
        int row = matrix.size();
        int col = matrix[0].size();
        vector<vector<int> > flag (row, vector<int>(col, 0)); // 标记没有走过的点
        int tx = 0, ty = 0;
        // (x,y) 当前位置 k 总过走多少 d 方向 
        for(int x = 0, y = 0, k = 1, d = 0; k <= row*col; k++)
        {
            flag[x][y] = 1; // 标记已走过
            res.push_back(matrix[x][y]);
            int a = x + dx[d], b = y + dy[d]; // 下一步走法
            if(a < 0 || a >= row || b < 0 || b >= col || flag[a][b])
            {
                d = (d+1)%4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
```



##### 螺旋矩阵 II

给定一个正整数 *n*，生成一个包含 1 到 *n*2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int dx[4] = {0,1,0,-1};
        int dy[4] = {1,0,-1,0};
        vector<vector<int> > res (n, vector<int>(n, 0)); 
        
        // (x,y) 当前位置 k 总过走多少 d 方向 
        for(int x = 0, y = 0, k = 1, d = 0; k <= n*n; k++)
        {
            res[x][y] = k;
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b < 0 || b >= n || res[a][b])
            {
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        
        return res;
    }
};
```



#### 合并两个有序数组

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *num1* 成为一个有序数组。

**说明:**

- 初始化 *nums1* 和 *nums2* 的元素数量分别为 *m* 和 *n* 。
- 你可以假设 *nums1* 有足够的空间（空间大小大于或等于 *m + n*）来保存 *nums2* 中的元素。

```c++
// 从后往前遍历 即可 
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int idx = m + n - 1;
        int p = m-1, q = n-1;
        while(idx >= 0 && p >= 0 && q >= 0)
        {
            if(nums1[p] > nums2[q])
            {
                nums1[idx--] = nums1[p--];
            }
            else
                nums1[idx--] = nums2[q--];
        }
        while(p >= 0)
            nums1[idx--] = nums1[p--];
        while(q >= 0)
            nums1[idx--] = nums2[q--];
    }
};
```



#### 链表突击

##### 反转链表

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
// 迭代法  原地反转 
/*
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr)
            return head;
        ListNode  *cur = head, *pre = nullptr;
        while(cur)
        {
            ListNode *pnext = cur->next;
            //if(pnext == NULL)
             //   p = pnext;
            // 这个地方可以不用判断最后的值 cur 为空 跳出循环的时候 pre 为最后一个
            cur->next = pre;
            pre = cur;
            cur = pnext;
        }
        return pre;
    }
};
*/
// 递归法 
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
       if(head == NULL || head->next == NULL)
           return head;
        else 
        {
            ListNode *p = reverseList(head->next); // 递归反转后面的部分 
            head->next->next = head;
            head->next = NULL; 
            //最后的一个指针next 指前 倒数第二个指后的断开
            return p;
        }
    }
};
```



##### 两数相加

给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```c++
// 模拟即可 记录进位
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *idx1 = l1, *idx2 = l2;
        ListNode *h = new ListNode(-1);
        ListNode *idx = h;
        int count = 0, sum = 0;
        if(l1 == nullptr)
            return l2;
        if(l2 == nullptr)
            return l1;
        while(idx1!=nullptr || idx2!=nullptr)
        {
            sum = 0;
            if(idx1!=nullptr)
            {
                sum += idx1->val;
                idx1 = idx1->next;
            }
            if(idx2!=nullptr)
            {
                sum += idx2->val;
                idx2 = idx2->next;
            }
            if(count) sum++;
            if(sum > 9)
            {
                count = 1;
                sum %= 10;
            }else count = 0;
            idx->next = new ListNode(sum);
            idx = idx->next;
        }
        if(count)
        {
            idx->next = new ListNode(count);
        }
        return h->next;
    }
};
```



#####  合并两个有序链表

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```c++
// 你声明的是指针 必须要指向一个ListNode
// 依次遍历 最后判一下 接在后面
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *p = new ListNode(-1);
        ListNode *idx = p;
        while(l1 && l2)
        {
            if(l1->val > l2->val)
            {
                idx->next = l2;
                l2 = l2->next;
            }else
            {
                idx->next = l1;
                l1 = l1->next;
            }
            idx = idx->next;       
        }
        if(l1)
            idx->next = l1;
        if(l2)
            idx->next = l2;
        return p->next;
    }
};
```



##### 合并K个排序链表

合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例:**

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

```c++
// 顺次返回 迭代一下即可
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *merge2(ListNode *l1, ListNode *l2)
    {
        ListNode *p = new ListNode(-1);
        ListNode *idx = p;
        while(l1 && l2)
        {
            if(l1->val > l2->val)
            {
                idx->next = l2;
                l2 = l2->next;
            }else
            {
                idx->next = l1;
                l1 = l1->next;
            }
            idx = idx->next;
        }
        if(l1)
            idx->next = l1;
        if(l2)
            idx->next = l2;
        return p->next;
    }
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int size = lists.size();
        if (size == 0) {
            return nullptr;
        }
        if (size == 1) {
            return lists[0];
        }
        ListNode *p = lists[0];
        for (int i = 1; i < size; ++i) {
            p = merge2(p, lists[i]);
        } 
        return p;
    }
};
```



##### 旋转链表

给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数。

**示例 1:**

```
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```

```c++
// 变环 再去旋转
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head==0 || head->next==0) return head;
        ListNode *idx = head;
        int length = 1;
        while(idx->next)
        {
            length++;
            idx = idx->next;
        }
        idx->next = head;
        k = k % length;
        idx = head;
        int j = length - k - 1;
        while(j--)
            idx = idx->next;
        ListNode *res = idx->next;
        idx->next = NULL; // 链表的末端一定要有NULL 才可以
        return res;
    }
};
```



##### 环形链表

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

```c++
// 快慢指针 最后是否可以走到同一点
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == NULL)
            return false;
        ListNode *slow = head, *fast = head;
        while(fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast)
                return true;
        }
        return false;
    }
};
```



##### 环形链表 II

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**说明：**不允许修改给定的链表。

```c++
// 先判断是否有环 忧环 则 相遇点必在环中 
// 再绕环一圈 看一下环的节点数 
// 已知环中节点数量，让两个指针从头出发 一个先行节点数量步 然后二者相遇则为环的入口
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        ListNode *idx = nullptr, *temp = nullptr;
        int count = 0; // 环中节点数 
        //快慢指针 相遇必在环中 
        while(fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast)
            {
                temp = fast;
                break;
            }
        }
        if(temp == NULL)
            return nullptr;
        idx = temp;
        while(1)
        {
            idx = idx->next;
            count++;
            if(idx == temp)
                break;
        }
        // 已知环中节点数量，让两个指针从头出发 一个先行节点数量步 然后二者相遇则为环的入口
        slow = head, fast = head;
        while(count--)
            fast = fast->next;
        while(fast != slow)
        {
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
};
```



##### 相交链表

编写一个程序，找到两个单链表相交的起始节点。

```c++
// 两个指针分别遍历 ，遍历完换一个继续遍历 
// 当两个指针相等的时候 就是两链表的相交点
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *l1 = headA, *l2 = headB;
        if(!headA || !headB)
            return nullptr;
        while(l1 != l2)
        {
            if(l1 == nullptr)
                l1 = headB;
            else l1 = l1->next;
            if(l2 == nullptr)
                l2 = headA;
            else l2 = l2->next;
        }
        return l1;
    }
};
```



##### 删除链表中的节点

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```



#### 数学与数字

##### 整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

```c++
// 注意判 溢出 
class Solution {
public:
    int reverse(int x) {
        int temp = x;
        int res = 0;
        while(temp!= 0)
        {
            
            int r = temp % 10;
            if(res > INT_MAX / 10 || res < INT_MIN / 10)
                return 0;
            res = res * 10 + r;
            temp /= 10;
        }
        return res;
    }
};
```



##### 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```c++
// 直接x 倒过来 看是否相等
class Solution {
public:
    bool isPalindrome(int x) {
        int temp = x;
        int res = 0;
        if(x < 0)
            return false;
        while(temp != 0)
        {
            int r = temp % 10;
            if(res > INT_MAX / 10 || (res == INT_MAX && r >= 7))
                return false;
            res = res * 10 + r;
            temp /= 10;
        }
        return res == x;
    }
};
```



##### 只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```c++
// 所有异或 结果就为那个只出现一次的数
// 异或 相同 取得 0 不同 取 1 
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < nums.size(); i++)
            res ^= nums[i];
        return res;
    }
};
```



##### 多数元素

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```c++
// sort 排序 中间位置的数字 
// 摩尔投票法  兑子打法 
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int target = nums[0];
        int cnt = 1;
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] == target)
                cnt++;
            else
            {
                cnt--;
                if(cnt == 0)
                {
                    target = nums[i];
                    cnt = 1;
                }
            }
        }
        return target;
    }
};
```



##### 2的幂

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

```c++
// 位运算 判断 
// n & n-1 == 0
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n == 0 || n == INT_MIN)
            return false;
        return !(n & n - 1);
    }
};
```



#### 排序与搜索

##### 排序链表



##### 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

```c++
// 二分查找 
// 难点：如何确定找左 还是找右 ?  
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.empty())
            return -1;
        int n = nums.size();
        int res = search2(nums, target, 0 , n-1);
        return res;
    }
    int search2(vector<int> & a, int target, int left, int right)
    {
        int mid = (left + right) / 2;
        if(target == a[mid])
            return mid;
        else if(target > a[mid])
        {
            if(a[left] < a[mid])
                return search2(a, target, mid+1, right);
            else 
                return search2(a, target, left, mid);
        }else
        {
            if(a[left] < a[mid] && a[mid] < a[right] || (a[left] > a[mid] && a[mid] < a[right]))
                return search2(a, target, left, mid);
            else 
                return search2(a, target, mid+1, right);
        }
        return -1;
    }
};
```



##### 数组中的第K个最大元素

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

```c++
// quick_sort_k
// heap 
/*
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> heap;
        for(int i = 0; i < nums.size(); i++)
            heap.push(nums[i]);
        for(int i = 1; i < k; i++)
            heap.pop();
        int res = heap.top();
        return res;
    }
};
*/
// quick_sort_k
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        int res = quick_sort(nums, 0 , n-1, k);
        return res;
    }
    int quick_sort(vector<int> nums, int left, int right, int k)
    {
        if(left >= right)
            return nums[left];
        int i = left - 1, j = right + 1, x = nums[(left + right) / 2];
        while(i < j)
        {
            do i++; while(nums[i] > x);
            do j--; while(nums[j] < x);
            if(i < j) swap(nums[i], nums[j]);
        }
        if(j - left + 1 >= k ) return quick_sort(nums, left, j, k);
        else return quick_sort(nums, j+1, right,  k - (j - left + 1));
    }
    
};
```



##### 二叉搜索树中第K小的元素

给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 **k** 个最小的元素。

**说明：**
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

```c++
// 中序遍历 递增序列  记录该序列
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
// 递归解法
/*
class Solution {
public:
    vector<int> res;
    int kthSmallest(TreeNode* root, int k) {
        if(root == nullptr)
            return 0;
        Find(root);
        return res[--k];
    }
    void Find(TreeNode *root)
    {
        if(root == nullptr)
            return;
        Find(root->left);
        res.push_back(root->val);
        Find(root->right);
    }
};
*/

// 迭代解法

class Solution {
public:
    vector<int> res;
    int kthSmallest(TreeNode* root, int k) {
        if(root == nullptr)
            return 0;
        stack<TreeNode*> stk;
        while(!stk.empty() || root)
        {
            while(root)
            {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            if(--k == 0)
                return root->val;
            root = root-> right;
        }
        return 0;
    }
};
```



##### 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
// 递归
/*
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        return Find(root);
    }
    int Find(TreeNode *root)
    {
        if(root == nullptr)
            return 0;
        return max(Find(root->left), Find(root->right)) + 1;
    }
};
*/
// 迭代
// 利用队列进行层次遍历 记录深度 一层记录一次 这个地方是要注意的用一个计数器 去把每一层的都更新掉
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        queue<TreeNode *> q;
        TreeNode *temp;
        int depth = 0;
        q.push(root);
        while(!q.empty())
        {
            depth++;
            int cur = q.size();
            while(cur--)
            {   
                temp = q.front();
                q.pop();
                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);                
            } 
        }
        return depth;
    }
};
```



##### 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

```c++
// 根据二叉搜索树的特点，第一个值介于[p->val, q->val]之间的节点即为所求
// 递归搜索一下即可 和p 或 q 比较均可以 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr)
            return root;
        if((root->val - p->val) * (root->val - q->val) <= 0)
            return root;
        if(root->val > p->val)
            return lowestCommonAncestor(root->left, p, q);
        if(root->val < p->val)
            return lowestCommonAncestor(root->right, p ,q);
        return nullptr;
    }
};
```



##### 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

```c++
// 两种情况 pq 在相同子树 pq 不在相同子树 
// 当前节点 的左右节点 均可 返回 pq 则其为公共祖先
// 从根节点遍历，递归向左右子树查询节点信息
// 递归终止条件：如果当前节点为空或等于p或q，则返回当前节点
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left && right) return root;
        return left ? left : right; // 从头开始找的不可能同时为空
    }
};


```



#### 数据结构概念问题 

##### 给个数组,判断是不是二叉搜索树的后序遍历

在后续遍历得到的序列中，最后一个元素为树的根结点。从头开始扫描这个序列，比根结点小的元素都应该位于序列的左半部分；从第一个大于跟结点开始到跟结点前面的一个元素为止，所有元素都应该大于跟结点，因为这部分元素对应的是树的右子树。根据这样的划分，把序列划分为左右两部分，我们递归地确认序列的左、右两部分是不是都是二元查找树



##### 二叉查找树是什么，简单叙述怎么实现的

二叉搜索树 左<中<根  查 增 删 【找到target 之后 如果只有一个子树直接顶上去， 如果有两个子树 要把右子树最小值变为当前节点】



##### 判断一个单链表有没有环

快慢指针 相遇必定在环中



##### 最长非重复子串

```c++
// 滑动窗口 front back 
// 每次看当前的是否在front - back中出现 这样复杂度是 O(n^2)
// 那么我们有哈希去查找的话 就会更快 
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> list;
        int res = 0;
        int idx = 0;
        int h = 0; // 记录窗口开始的地方
        int t = 0; // 记录窗口结尾的地方
        unordered_map<char, int> hash;
        for(int i = 0; i < s.length(); i++)
        {
            // 前边出现则更新 h
            if(hash.count(s[i]) && hash[s[i]] >= h)
            {
                h = hash[s[i]] + 1;
            }
            t = i;
            hash[s[i]] = i;
            res = t - h + 1 > res ? t - h + 1 : res;
        }
        return res;
    }
};
```



##### 如何减少哈希冲突？

hash冲突的解决：开放定址法 拉链法 再哈希 建立公共溢出区



##### avl 红黑树 b树  b+树 

b树  平衡多路查找树

数据库索引采用B+树的主要原因是:B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题,正是为了解决这个问题,B+树应用而生.B+树只需要去**遍历叶子节点**就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）.　　　



##### 数字出现的次数

一个数奇数次，其他偶数次 -> 全部异或 res为答案

两个数偶数次，其它 奇数次 -> 全部异或拆分两个数组再 异或



##### 最短编辑距离



##### 最小栈

构建两个栈，一个栈为主栈，存储数据；另一个栈为副栈，存当前数据的最小值。
在每一次push的时候，主栈正常push，压入数据；
副栈需要执行一次判断，如果当前值小于等于顶点值，在入栈
反之则当前值是最小值，依次类推即可。

```c++
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> m_s;
    stack<int> m_min_s;
    MinStack() {

    }
    
    void push(int x) {
        if(m_min_s.empty() || x <= getMin()) //注意：相等也入栈
            m_min_s.push(x);
        m_s.push(x);
    }
    
    void pop() {
        if(m_s.top() == m_min_s.top())
            m_min_s.pop();
        m_s.pop();
    }
    
    int top() {
        return m_s.top();
    }
    
    int getMin() {
        return m_min_s.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```



##### redis 渐进式hash



##### 字典序排序



##### 字典序

```c++
// dfs 从 1-9 开始依次往后dfs 
class Solution {
public:
    void dfs(int k, int n, vector<int> &res)
    {
        if(k > n) return;
        if(k) res.push_back(k);
        for(int i = 0; i <= 9; i++)
        {
            if(k*10 + i > 0)
                dfs(k*10+i, n, res);
        }
    }

    vector<int> lexicalOrder(int n) {
        vector<int> res;
        dfs(0,n,res);
        return res;
    }
};
```



##### 二叉树的高度

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};


// 迭代
// 利用队列进行层次遍历 记录深度 一层记录一次 这个地方是要注意的用一个计数器 去把每一层的都更新掉
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        queue<TreeNode *> q;
        TreeNode *temp;
        int depth = 0;
        q.push(root);
        while(!q.empty())
        {
            depth++;
            int cur = q.size();
            while(cur--)
            {   
                temp = q.front();
                q.pop();
                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);                
            } 
        }
        return depth;
    }
};
```

n个节点二叉树的高度 logn 



##### 二叉树镜像 交换左右节点

先序遍历 -> 递归 栈 模拟即可



