#### c++基础

----

##### static 关键字的作用

1）修饰普通变量，会修改变量的存储区域和生命周期，变量会存储在静态存储区，在整个程序运行期间一直存在，未经初始化则自动初始化为0，其中，全局静态变量文件内可见，局部静态变量作用域在定义它的函数或语句块内，但是当再次调用的的时候值保持不变

2）修饰函数，静态函数，只可在本cpp内使用，不会同其他cpp中的同名函数起冲突

注意：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果该函数需要多个cpp复用则声明提到头文件，否则cpp内部声明需要加上static修饰

##### 3）修饰类的成员和函数，静态成员可以实现多个对象之间的数据共享 ，类的静态成员函数，实现过程不能直接引用类中的非静态成员，调用静态成员函数 <类名>::<静态成员函数名>(<参数表>)



##### c++ static 和 const 的作用 

1）const 两个作用 限定变量为不可修改 限定成员函数不可以修改任何数据成员 修饰指针的话 const char *p 表示指向的内容不可以改变 char *const p 就是将P声明为常指针 地址不能改变 但是具体的内容可以改变 

2）static 和 const 不可以同时修饰一个函数 



##### 动态存储区、静态存储区、堆和栈的区别

c程序编译后形成的二进制映像文件，包含：栈、堆、数据段、代码段 

栈区：函数调用 局部变量 

堆区：程序员动态申请 链表实现

程序代码、数据段：静态区域

程序代码：存放cpu指令

数据段：

1）只读数据段 

程序使用的const 修饰变量 和 字符串常量 

2）已初始化的读写数据段

已经初始化的全局变量 或是

![img](https://img-blog.csdn.net/20170208175930830?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbjEwODMzNzY1MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

##### 说一下c++和c的区别

1）设计思想上，c++ 是面向对象的语言，c是面向过程的结构化编程语言

2）语法上，c++具有**封装、继承和多态**三种特性，c++增加了**类型安全功能**（强制类型转换），c++支持**范式编程** 



##### 泛型编程

泛型编程就是指编写独立于特定类型的代码，stl ，可以在使用的时候再去指定元素类型 

函数模板 一种独立于类型的特殊函数  由函数模板可以产生针对特定类型的函数版本 

```c++
template <typename T>
int compare(const T &lhs, const T &rhs)
{
    if(lhs < rhs) return -1;
    if(rhs < lhs) return 1;
    return 0;
}
```



##### typedef 和 define的区别 

#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。

typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。

#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域【同变量的作用域】。



##### 重载和重写的区别

1）重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。

2）重写：也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override) 被重写的函数需要是virtual的 必须有相同的类型 名称和参数列表 访问修饰符可以不同

3）重定义：

a 、如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。

b 、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏（如果相同有Virtual就是重写覆盖了）。



##### c/c++指针和引用的区别

`int &r = i;// r是i的引用`

1）指针是一个变量，存储的是一个地址，指向内存的一个存储单元，引用仅是个别名

2）引用使用时候无需解引用*, 指针需要 

3）引用只能在定义的时候被初始化一次 然后不可变 

4）引用不能为空 不可const修饰 指针可以为空 可以被const 修饰

5）sizeof 引用 大小需要看其所指向的变量的大小，而sizeof指针 则是指针本身的大小，一般为￥B

6）指针和引用的自增运算不同 r++ == (*p)++

7）指针可以有多级，引用只有一级

6）程序为指针变量分配内存区域，引用无需分配内存区域



##### 数组和指针的区别 

| 指针                                                         | 数组                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| 保存数据的地址                                               | 保存数据                             |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据                         |
| 通常用于动态的数据结构                                       | 通常用于固定数目且数据类型相同的元素 |
| 通过malloc分配内存 free 释放内存                             | 隐式的分配和删除                     |
| 通常指向（匿名函数，操作匿名函数） ?                         | 自身即为数据名                       |



##### 什么是野指针 

**当所指向的对象被释放或者收回**，但是对该**指针**没有作任何的修改，以至于该**指针**仍旧指向已经回收的内存地址，此情况下该**指针**便称野指针



##### 什么是函数指针 

函数指针是指向函数的指针变量 ，c在编译的时候，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址 

```c++
char fun(char * p)  {…}       // 函数fun
char (*pf)(char * p);             // 函数指针pf
pf = fun;                        // 函数指针pf指向函数fun
pf(p);                        // 通过函数指针pf调用函数fun
```



##### 请你来回答一下const修饰成员函数的目的是什么？

const修饰的成员函数表明**函数调用不会对对象做出任何更改**，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。



#####  请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？

常量在C++里的定义就是一个const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量(如字符串)，常量存放在**常量存储区**。



##### 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？

如果是在一个类中 则不会，普通的函数会，编译的时候无法区分 

如果成员函数的后面加上了const，就表示这个成员函数不能对数据成员进行任何的修改动作。我把每个函数的声明都写好，不能修改数据成员的函数我在后面加上const。首先你的函数的实现也必须加上相应的const，否则函数的声明和实现不同，跑不起来；其次只要你在函数后面加上了const，就不能修改数据成员了



##### 请你说说C语言是怎么进行函数调用的？



##### 请你回答一下malloc与new区别

malloc 需要给定申请内存的大小，**返回的指针需要强制转换类型**

new 会调用构造函数，不用指定内存大小，返回的指针不用强制转换



#####  请你说一说vector和list的区别，应用，越详细越好

1）vector 动态数组，在堆上分配空间 

底层实现是数组，可随机访问 两倍容量增长（循环如何解决效率问题）

2）List 动态链表 在堆上分配空间

底层实现是双向链表  顺序访问 每插入一个元数都会分配空间，每删除一个元素都会释放空间



##### n个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为O(N)

单调栈，用栈维护，以及开一个数组存放每一个结果，当前值大于栈顶元素 则放入数组 栈顶元素弹出并放入当前值，如果小于栈顶元素 则入栈继续往后找res[stk.top()] = 当前值  stk 存放是的索引 



##### 请你来说一下C++中struct和class的区别

在C++中，可以用struct和class定义类，都可以继承。区别在于：struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。



##### 请你回答一下C++类内可以定义引用数据成员吗？

可以，必须通过成员函数**初始化列表初始化**。



##### 请你来说一下一个C++源文件从文本到可执行文件经历的过程？

1）预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件

2）编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件

3）汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

4）链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件



##### 请你来回答一下include头文件的顺序以及双引号””和尖括号<>的区别？

1）" " 和 <> 的区别在于 编译器预处理阶段查找头文件的路径不一样 

“ ” ： 当前头文件目录 -> 编译器设置的头文件目录 -> 系统变量

<>: 编译器设置的头文件目录 -> 系统变量

2）include 头文件的顺序 



#####  请你来说一下什么时候会发生段错误

段错误通常发生在访问非法内存地址的时候，一般就是使用野指针，数组访问越界，试图修改字符串常量的内容 



##### main函数返回值的作用 

main函数的返回值用于说明程序的退出状态。如果返回0，则代表程序正常退出。返回其它数字的含义则由系统决定。通常，返回非零代表程序异常退出。



##### C/C++中如何在main()函数之前执行一条语句？

利用全局对象的构造函数

C和C++中的一般全局变量（不包括类class）是在编译期确定的初始值，而不是在程序运行时，在main函数之前初始化的。

C++中的类的全局变量是在程序运行时，在main函数之前初始化的。



##### 解释下封装、继承和多态

封装：封装就是将数据或函数封装在一个单元中 我们称之为类，封装的意义在于保护或者防止数据被我们无意破环 

继承：实现重用代码，节省开发时间 

多态：程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数



##### c++中的多态

接口的最大程度复用 一个接口多个方法 

1）静态多态： 函数重载 以及 泛型编程

编译期间完成，编译器会根据实参类型来选择调用合适的函数

2）动态多态：

**程序运行时**根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数  动态绑定 。



##### 虚函数 

在基类中使用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数的时候，可根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接

```c++
#include <iostream> 
using namespace std;
 
class Shape {
   protected:
      int width, height;
   public:
      virtual Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
 
   // 存储矩形的地址
   shape = &rec;
   // 调用矩形的求面积函数 area
   shape->area();
 
   // 存储三角形的地址
   shape = &tri;
   // 调用三角形的求面积函数 area
   shape->area();
   
   return 0;
}
```



##### 成员函数在内存结构中哪个位置

代码区 

C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。



##### 构造函数是否可以是虚函数，为什么

构造函数没有必要是虚函数。 虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。 而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。



