#### 操作系统

---

##### 线程和进程的区别

1）进程是系统资源分配的基本单位，线程是cpu调度的基本单位

2）一个进程可有多个线程，线程间共享该进程的所有资源（代码段，数据段，扩展段，堆栈段），但各自有自己的线程上下文：寄存器组，程序计数器，栈空间，处理器状态等 

3）进程切换开销大，涉及到整个当前进程CPU环境的保存以及新被调度的进程的CPU运行环境

4）同进程间的线程的同步及通信容易实现（有相同的地址空间），进程间通信较为麻烦



##### 进程间的通信方式

每个进程各自拥有不同的用户地址空间，彼此不可见，所以需要进程间的通信

1）管道 / 匿名管道

半双工的，数据只能向一个方向流动

实质是内核缓冲区，进程以先进先出的方式从缓冲区读取数据

只能用于具有亲缘关系的进程

->有名管道 任意两进程均可

2）信号

信号可以在任何时候发给某个进程，而无需知道其状态，硬件来源 / 软件终止

3）消息队列

存放在内核中的消息链表，

4）共享内存

多个进程直接读写同一个块内存空间 速度最快

（需要同步机制来实现进程间的同步与互斥）

5）信号量

信号量是一个计数器，用于多进程对共享数据的访问，实现进程间的同步 pv操作（等待，释放）

信号量和互斥量之间的区别：

互斥量 二值 是用于线程的互斥，指某一资源同时只允许一个访问者访问 

信号量 非负整数，用于线程的同步，多个同类资源的多线程的互斥和同步 

6）套接字

不同计算机网络间通信 利用三元组（ip，协议，端口）唯一标识进程



##### 线程间的同步方式

各个线程可以访问进程中的公共变量、资源，问题在于如何方式多个线程同时访问一个数据，破坏数据的完整性，故需要一些线程间的同步方式 

1）临界区

开辟临界区，使得多线程串行化访问

2）互斥量

只有拥有互斥对象的线程才有访问公共资源的权限

3）信号量 

允许多个线程在同一个时刻去访问同一个资源但会限制最大数量

4）信号 

通过通知的方式来保持多线程同步



##### 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的

线程在切换的时候需要保存当前线程ID，线程状态，栈，寄存器组等，寄存器主要包括SP PC EAX等寄存器

SP：堆栈指针， 指向当前栈的栈顶地址 

PC：程序计数器，存储下一条将要执行的指令

EAX：累加寄存器，用于加法乘法的缺省寄存器



##### 线程有什么共享资源和独占资源

共享资源：进程的代码段/ 公有数据 / 进程用户ID 等

独占资源：线程ID, 寄存器组，栈，线程优先级等

寄存器组主要包括：堆栈指针，程序计数器，累加寄存器等



##### 线程栈溢出会影响别的线程吗？

不会，独立的空间 ， 当发生溢出后会报告段错误，然后动态增长  内核会动态调整的



##### 栈和堆里的数据有什么区别

栈：后进先出 

堆：经过排序的树形数据结构

在os中：

栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

栈中变量运行时赋值，堆中变量 编译时赋值 



##### 如何应对高并发访问

服务端：分而治之 提高处理单个请求的速度

增加资源供给：比如：更大的网络带宽，使用更高配置的服务器，使用高性能的Web服务器，使用高性能的数据库

请求分流：使用集群,分布式的系统架构

应用优化：使用更高效的编程语言,优化处理业务逻辑的算法,优化访问数据库的SQL



##### 死锁

1）死锁的四个必要条件：

互斥条件：一个资源只能被一个进程使用

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 

不剥夺条件：进程已获得的资源，在未完成之前，不能强行剥夺

循环等待条件：若干进程之间形成循环等待关系

2）死锁的处理：

a）死锁的预防

不允许死锁的发生，破除死锁发生的四个必要条件 分层

b）死锁的检测 与 解除

当系统检测到发生死锁的时候 则 开始将进程从死锁状态解脱 ，如：资源剥夺 撤销进程

c）死锁的避免

确保安全序列， 资源请求图算法 / 银行家算法



##### 操作系统为什么要分内核态和用户态

为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。



##### 程序分段 及各个段的作用

程序段 数据段（data,bss 初始化数据 / 未初始化数据）堆栈段 

程序段（放代码 只读）

数据段：data 有初值的全局变量和static变量 bss 未初始化的全局变量 

堆栈段：栈 局部变量 堆 动态分配内存 



##### 计算机存储数值用的是源码反码还是补码，为什么

补码，实现加减法的运算统一 

正数的补码是其本身 

负数的补码是除符号位其数值位取反加一

符号位 正数为0 负数为1



#####  请你说一说并发(concurrency)和并行(parallelism)

并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。

并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。



##### linux的四种锁机制 

1）互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

2）读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。写者优先级高于读者 

3）自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。【同mutex 但是会等待】



##### 进程的状态转换 

执行 就绪 等待 

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F)

当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。

-> 两种解决办法：交换技术 / 虚拟存储技术



##### 请问什么是大端小端以及如何判断大端小端

大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。



##### 请你说一说用户态和内核态区别

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。



##### 内存溢出和内存泄漏

内存溢出： 指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误

内存泄漏：内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。



##### 线程池的优点

线程池 是一个或多个线程的循环执行的队列 

1）避免线程的创建和销毁带来的性能开销。
2）避免大量的线程间因互相抢占系统资源导致的阻塞现象。
3｝能够对线程进行简单的管理并提供定时执行、间隔执行等功能。



##### 存储器层次结构 

CPU缓存，内存，交换区，磁盘

存储器层次结构的优点在于，作为一个整体，它的容量相当于最底层的存储设备的容量，而它的速度却相当于最顶层存储设备的速度